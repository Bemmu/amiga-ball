<!DOCTYPE html>
<html lang="en">
  <head>
    <title>3d ball</title>
  </head>
  <body>
    <canvas id="amiga3d"></canvas>
    <script>
      function amigaBallSetup() {
        var options = {
          canvasSize: 500,
          canvasOffset: 10,
          canvasTitle: "Amiga Ball",
          backgroundColor: "gray",
          followScroll: true,
          destinationId: "amiga3d",
          fps: 15
        };

        var canvas = document.getElementById(options.destinationId);
        var ctx = canvas.getContext('2d');
        var ball = new amigaBall(20);
        var rotation = 0;
        var distance = 0;

        function Point3D() {
          this.x = 0;
          this.y = 0;
          this.z = 0;
          this.bx = 0;
          this.by = 0;
          this.bz = 0;
          this.px = 0;
          this.py = 0;
          this.row = 0;
          this.column = 0;
          this.title = 'bla';
        }

        function amigaBall(radius) {
          this.point = new Array();
          this.color = "rgb(100, 0, 255)";
          this.radius = radius;
          this.numberOfVertexes = 0;
          this.degMax = Math.PI * 2;
          this.degPitch = this.degMax / 16;

          var column = 0;
          for (alpha = 0; alpha <= this.degMax; alpha += this.degPitch) {
            var p = this.point[this.numberOfVertexes] = new Point3D();
            p.x = Math.cos(alpha) * this.radius;
            p.y = 0;
            p.z = Math.sin(alpha) * this.radius;
            p.bx = p.x;
            p.by = p.y;
            p.bz = p.z;
            p.row = 0;
            p.column = column;
            column++;
            this.numberOfVertexes++;
          }

          for (var direction = 1; direction >= -1; direction -= 2) {
            var row = direction;
            for (var beta = this.degPitch; beta <= Math.PI / 2 + 0.001; beta += this.degPitch) {
              var radius = Math.cos(beta) * this.radius;
              var fixedY = Math.sin(beta) * this.radius * direction;
              var column = 0;
              for (var alpha = 0; alpha < this.degMax; alpha += this.degPitch) {
                var p = this.point[this.numberOfVertexes] = new Point3D();
                p.x = Math.cos(alpha) * radius;
                p.y = fixedY;
                p.z = Math.sin(alpha) * radius;
                p.bx = p.x;
                p.by = p.y;
                p.bz = p.z;
                p.row = row;
                p.column = column;
                this.numberOfVertexes++;
                column++;
              }
              row += direction;
            }
          }

          this.grid = {};
          for (var i = 0; i < this.numberOfVertexes; i++) {
            var p = this.point[i];
            if (typeof(this.grid[p.row]) == 'undefined') {
              this.grid[p.row] = {};
            }
            this.grid[p.row][p.column] = p;
          }
          this.columns = this.grid[0].length;
          this.rows = this.grid.length;
          //console.log(this.grid);
        }

        function rotatePoint(point, radians) {
          var sinrad = Math.sin(radians);
          var cosrad = Math.cos(radians);
          var xyOffset = canvas.width / 2.0;

          point.x = point.bx;
          point.y = point.by;
          point.z = point.bz;

          // rotation
          var y = point.y;
          point.y = y * cosrad - point.z * sinrad;
          point.z = y * sinrad + point.z * cosrad;

          var x = point.x;
          point.x = x * cosrad - point.z * sinrad;
          point.z = x * sinrad + point.z * cosrad;

          x = point.x;
          point.x = x * cosrad - point.z * sinrad;
          point.z = x * sinrad + point.z * cosrad;

          // projection
          point.px = distance * point.x / (point.z - 100.0) + xyOffset;
          point.py = distance * point.y / (point.z - 100.0) + xyOffset;
        }

/*         function rotateX(point, radians) { */
/*           var y = point.y; */
/*           point.y = (y * Math.cos(radians)) + (point.z * Math.sin(radians) * -1.0); */
/*           point.z = (y * Math.sin(radians)) + (point.z * Math.cos(radians)); */
/*         } */

/*         function rotateY(point, radians) { */
/*           var x = point.x; */
/*           point.x = (x * Math.cos(radians)) + (point.z * Math.sin(radians) * -1.0); */
/*           point.z = (x * Math.sin(radians)) + (point.z * Math.cos(radians)); */
/*         } */

/*         function rotateZ(point, radians) { */
/*           var x = point.x; */
/*           point.x = (x * Math.cos(radians)) + (point.z * Math.sin(radians) * -1.0); */
/*           point.z = (x * Math.sin(radians)) + (point.z * Math.cos(radians)); */
/*         } */

/*         function projection(xy, z, xyOffset, zOffset, distance) { */
/*           return ((distance * xy) / (z - zOffset)) + xyOffset; */
/*         } */

        function drawPointWithGradient(ctx, p, size, color, gradient) {
          var reflection = size / 4;
          ctx.save();
          ctx.translate(p.px, p.py);
          var radgrad = ctx.createRadialGradient(-reflection, -reflection, reflection, 0, 0, size);
          radgrad.addColorStop(0, '#FFFFFF');
          radgrad.addColorStop(gradient, color);
          radgrad.addColorStop(1, 'rgba(1, 159, 98, 0)');
          ctx.fillStyle = radgrad;
          ctx.fillRect(-size, -size, size * 2, size * 2);
          ctx.restore();
          ctx.fillStyle = "rgb(0, 0, 0)";
          ctx.font = "13pt Arial";
          ctx.fillText(p.row + ':' + p.column, p.px, p.py);
          ctx.restore();
        }

        function drawPolygon(ctx, points, size, color) {
          ctx.save();
          ctx.beginPath();
          ctx.fillStyle = color;
          var p = points[0];
          ctx.moveTo(p.px, p.py);
          for (var i = 1; i < points.length; i++) {
            p = points[i];
            ctx.lineTo(p.px, p.py);
          }
          ctx.closePath();
          ctx.stroke();
          ctx.fill();
          ctx.restore();
        }

        function drawPoint(ctx, p, size, color) {
          ctx.save();
          ctx.beginPath();
          ctx.fillStyle = color;
          ctx.arc(p.px, p.py, size, 0, 2 * Math.PI, true);
          ctx.fill();
          ctx.restore();
          ctx.fillStyle = "rgb(0, 0, 0)";
          ctx.fillText(p.title, p.px, p.py);
          ctx.restore();
        }

        function render() {
          console.log("render");
          canvas.width = canvas.height = options.canvasSize;
          canvas.title = options.canvasTitle;
          canvas.style.zIndex = 100;
          canvas.style.cursor = "pointer";
          canvas.style.left = canvas.style.top = options.canvasOffset + 'px';
          canvas.style.backgroundColor = options.backgroundColor;
          document.body.appendChild(canvas);
          if (options.followScroll) {
            canvas.style.position = "absolute";
            var destinationY = positionY = options.canvasOffset;
            window.addEventListener("scroll", function() {
                destinationY = window.pageYOffset + options.canvasOffset;
              });
          }
          //var p = new Point3D();
          ctx.save();
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.globalCompositeOperation = 'lighter';
          //ctx.globalCompositeOperation = 'darker';

          for (var i = 0; i < ball.numberOfVertexes; i++) {
            //console.log(ball.point[0]);
            var p = ball.point[i];
            //p.x = ball.point[i].x;
            //p.y = ball.point[i].y;
            //p.z = ball.point[i].z;

            rotatePoint(p, rotation);

            //rotateX(p, rotation);
            //rotateY(p, rotation);
            //rotateZ(p, rotation);
            //console.info("test", p.x);

            //x = projection(p.x, p.z, canvas.width / 2.0, 100.0, distance);
            //y = projection(p.y, p.z, canvas.width / 2.0, 100.0, distance);
          }



          for (var i = 0; i < ball.numberOfVertexes; i++) {
            var p = ball.point[i];
            if (p.px >= 0 && p.px < canvas.width) {
              if (p.py >= 0 && p.py < canvas.height) {
                if (p.z < 0) {
                  drawPoint(ctx, p, 3, "rgba(200, 200, 200, 0.6)");
                }
              }
            }
          }

          drawPolygon(ctx, [ball.point[42], ball.point[43], ball.point[20], ball.point[50], ball.point[72]], 10, "rgb(250, 0, 250)", 0.8);

          //alert(42);
          for (var i = 0; i < ball.numberOfVertexes; i++) {
            var p = ball.point[i];
            if (p.px >= 0 && p.px < canvas.width) {
              if (p.py >= 0 && p.py < canvas.height) {
                if (p.z >= 0) {
                  drawPointWithGradient(ctx, p, 5, "rgb(200, 0, 0)", 0.8);
                }
              }
            }
          }



          ctx.restore();
          //ctx.fillStyle = "rgb(0, 0, 0)";
          //ctx.fillText("test", canvas.width - 90, canvas.height - 50);

          //console.log(ball.point[42]);



          rotation += (Math.PI / 90.0) * .2;
          if (distance < 1000) {
            distance += 100;
          }
        }

        setInterval(render, 1000 / 15);

        console.log('Amiga ball initialized !');
      }

      amigaBallSetup();
    </script>
  </body>
</html>
